 Address    Code        Basic                     Source

0x00400000  0x3c0800f3  lui $8,0x000000f3     17   main:	lui	$t0,0xf3	#
0x00400004  0x00000000  nop                   18   	nop
0x00400008  0x00000000  nop                   19   	nop
0x0040000c  0x00000000  nop                   20   	nop
0x00400010  0x35080023  ori $8,$8,0x00000023  21   	ori	$t0,$t0,0x23	# $t0<= 0x00f30023
0x00400014  0x3c090052  lui $9,0x00000052     22   	lui	$t1,0x52	#
0x00400018  0x00000000  nop                   23   	nop
0x0040001c  0x00000000  nop                   24   	nop
0x00400020  0x00000000  nop                   25   	nop
0x00400024  0x352900e2  ori $9,$9,0x000000e2  26   	ori	$t1,$t1,0xe2	# $t1<= 0x005200e2
0x00400028  0x3c0a0000  lui $10,0x00000000    27   	lui	$t2,0x00	#
0x0040002c  0x354a008f  ori $10,$10,0x0000008f28   	ori	$t2,$t2,0x8f	# $t2<= 0x0000008f
0x00400030  0x00000000  nop                   29   	nop
0x00400034  0x00000000  nop                   30   	nop
0x00400038  0x00000000  nop                   31   	nop
0x0040003c  0x112a0064  beq $9,$10,0x00000064 32   	beq	$t1,$t2,loop	# Obviamente, esta instrução nunca deve saltarnop
0x00400040  0x00000000  nop                   33   	nop
0x00400044  0x00000000  nop                   34   	nop
0x00400048  0x00000000  nop                   35   	nop
0x0040004c  0x152a0005  bne $9,$10,0x00000005 36   	bne	$t1,$t2,next_i	# Obviamente, esta instrução sempre deve saltar
0x00400050  0x00000000  nop                   37   	nop
0x00400054  0x00000000  nop                   38   	nop
0x00400058  0x00000000  nop                   39   	nop
0x0040005c  0x00000000  nop                   40   	nop
0x00400060  0x254a008f  addiu $10,$10,0x00000041   	addiu	$t2,$t2,0x8f	# Obviamente, esta instrução nunca deve executar
0x00400064  0x01095821  addu $11,$8,$9        42   next_i:	addu	$t3,$t0,$t1	# $t3<= 0x00f30023 + 0x005200e2 = 0x01450105
0x00400068  0x01096023  subu $12,$8,$9        43   	subu	$t4,$t0,$t1	# $t4<= 0x00f30023 - 0x005200e2 = 0x00a0ff41
0x0040006c  0x01296823  subu $13,$9,$9        44   	subu	$t5,$t1,$t1	# $t5<= 0x0
0x00400070  0x01097024  and $14,$8,$9         45   	and	$t6,$t0,$t1	# $t6<= 0x00f30023 and 0x005200e2 = 0x00520022
0x00400074  0x01097825  or $15,$8,$9          46   	or	$t7,$t0,$t1	# $t7<= 0x00f30023 or  0x005200e2 = 0x00f300e3
0x00400078  0x0109c026  xor $24,$8,$9         47   	xor	$t8,$t0,$t1	# $t8<= 0x00f30023 xor 0x005200e2 = 0x00a100c1
0x0040007c  0x0109c827  nor $25,$8,$9         48   	nor	$t9,$t0,$t1	# $t9<= 0x00f30023 nor 0x005200e2 = 0xff0cff1c
0x00400080  0x250800ab  addiu $8,$8,0x000000ab49   	addiu	$t0,$t0,0x00ab	# $t0<= 0x00f30023  +  0x000000ab = 0x00f300ce
0x00400084  0x00000000  nop                   50   	nop
0x00400088  0x00000000  nop                   51   	nop
0x0040008c  0x00000000  nop                   52   	nop
0x00400090  0x310800ab  andi $8,$8,0x000000ab 53   	andi	$t0,$t0,0x00ab	# $t0<= 0x00f300ce and 0x000000ab = 0x0000008a
0x00400094  0x00000000  nop                   54   	nop
0x00400098  0x00000000  nop                   55   	nop
0x0040009c  0x00000000  nop                   56   	nop
0x004000a0  0x3908ffab  xori $8,$8,0x0000ffab 57   	xori	$t0,$t0,0xffab	# $t0<= 0x0000008a xor 0x0000ffab = 0x0000ff21
0x004000a4  0x00000000  nop                   58   	nop
0x004000a8  0x00000000  nop                   59   	nop
0x004000ac  0x00000000  nop                   60   	nop
0x004000b0  0x00084100  sll $8,$8,0x00000004  61   	sll	$t0,$t0,4	# $t0<= 0x000ff210 (deslocado 4 bits para a esquerda)
0x004000b4  0x00000000  nop                   62   	nop
0x004000b8  0x00000000  nop                   63   	nop
0x004000bc  0x00000000  nop                   64   	nop
0x004000c0  0x00084242  srl $8,$8,0x00000009  65   	srl	$t0,$t0,9	# $t0<= 0x000007f9 (deslocado 9 bits para a direita)
0x004000c4  0x24120008  addiu $18,$0,0x000000066   	addiu	$s2,$zero,8	# $s2<= 0x00000008
0x004000c8  0x02594004  sllv $8,$25,$18       67   	sllv	$t0,$t9,$s2	# $t0<= 0x0007f900
0x004000cc  0x00000000  nop                   68   	nop
0x004000d0  0x00000000  nop                   69   	nop
0x004000d4  0x00000000  nop                   70   	nop
0x004000d8  0x02484004  sllv $8,$8,$18        71   	sllv	$t0,$t0,$s2	# $t0<= 0x07f90000
0x004000dc  0x00000000  nop                   72   	nop
0x004000e0  0x00000000  nop                   73   	nop
0x004000e4  0x00000000  nop                   74   	nop
0x004000e8  0x02484004  sllv $8,$8,$18        75   	sllv	$t0,$t0,$s2	# $t0<= 0xf9000000
0x004000ec  0x00000000  nop                   76   	nop
0x004000f0  0x00000000  nop                   77   	nop
0x004000f4  0x00000000  nop                   78   	nop
0x004000f8  0x00084103  sra $8,$8,0x00000004  79   	sra	$t0,$t0,4	# $t0<= 0xff900000
0x004000fc  0x00000000  nop                   80   	nop
0x00400100  0x00000000  nop                   81   	nop
0x00400104  0x00000000  nop                   82   	nop
0x00400108  0x02484007  srav $8,$8,$18        83   	srav	$t0,$t0,$s2	# $t0<= 0xffff9000
0x0040010c  0x00000000  nop                   84   	nop
0x00400110  0x00000000  nop                   85   	nop
0x00400114  0x00000000  nop                   86   	nop
0x00400118  0x02484006  srlv $8,$8,$18        87   	srlv	$t0,$t0,$s2	# $t0<= 0x00ffff90
0x0040011c  0x3c011001  lui $1,0x00001001     88   	la	$t0,array	# coloca em $t0 o endereço inicial do vetor array (0x10010000)
0x00400120  0x34280000  ori $8,$1,0x00000000       
0x00400124  0x00000000  nop                   89   	nop
0x00400128  0x00000000  nop                   90   	nop
0x0040012c  0x00000000  nop                   91   	nop
0x00400130  0x91090006  lbu $9,0x00000006($8) 92   	lbu	$t1,6($t0)	# $t1<= 0x000000ef (primero byte é terceiro byte do segundo elemento)
0x00400134  0x00000000  nop                   93   	nop
0x00400138  0x00000000  nop                   94   	nop
0x0040013c  0x00000000  nop                   95   	nop
0x00400140  0x392900ff  xori $9,$9,0x000000ff 96   	xori	$t1,$t1,0xff	# $t1<= 0x00000010, inverte byte inferior
0x00400144  0x00000000  nop                   97   	nop
0x00400148  0x00000000  nop                   98   	nop
0x0040014c  0x00000000  nop                   99   	nop
0x00400150  0xa1090006  sb $9,0x00000006($8)  100  	sb	$t1,6($t0)	# segundo byte do segundo elemento do vetor <= 10 (resto não muda)
0x00400154  0x24080001  addiu $8,$0,0x00000001102  	addiu	$t0,$zero,0x1	# $t0<= 0x00000001
0x00400158  0x00000000  nop                   103  	nop
0x0040015c  0x00000000  nop                   104  	nop
0x00400160  0x00000000  nop                   105  	nop
0x00400164  0x00084023  subu $8,$0,$8         106  	subu	$t0,$zero,$t0	# $t0<= 0xffffffff
0x00400168  0x00000000  nop                   107  	nop
0x0040016c  0x00000000  nop                   108  	nop
0x00400170  0x00000000  nop                   109  	nop
0x00400174  0x05010016  bgez $8,0x00000016    110  	bgez	$t0,loop	# Esta instrução nunca deve saltar, pois $t0 = -1
0x00400178  0x00000000  nop                   111  	nop
0x0040017c  0x00000000  nop                   112  	nop
0x00400180  0x00000000  nop                   113  	nop
0x00400184  0x00000000  nop                   114  	nop
0x00400188  0x0109582a  slt $11,$8,$9         115  	slt	$t3,$t0,$t1	# $t3<= 0x00000001, pois -1 < 10
0x0040018c  0x0109582b  sltu $11,$8,$9        116  	sltu	$t3,$t0,$t1	# $t3<= 0x00000000, pois (2^32)-1 > 10
0x00400190  0x290b0001  slti $11,$8,0x00000001117  	slti	$t3,$t0,0x1	# $t3<= 0x00000001, pois -1 < 1
0x00400194  0x2d0b0001  sltiu $11,$8,0x0000000118  	sltiu	$t3,$t0,0x1	# $t3<= 0x00000000, pois (2^32)-1 > 1
0x00400198  0x3c011001  lui $1,0x00001001     122  soma_ct:la	$t0,array	# coloca em $t0 o endereço do vetor (0x10010000)
0x0040019c  0x34280000  ori $8,$1,0x00000000       
0x004001a0  0x3c011001  lui $1,0x00001001     123  	la	$t1,size	# coloca em $t1 o endereço do tamanho do vetor
0x004001a4  0x34290020  ori $9,$1,0x00000020       
0x004001a8  0x00000000  nop                   124  	nop
0x004001ac  0x00000000  nop                   125  	nop
0x004001b0  0x00000000  nop                   126  	nop 
0x004001b4  0x8d290000  lw $9,0x00000000($9)  127  	lw	$t1,0($t1)	# coloca em $t1 o tamanho do vetor
0x004001b8  0x3c011001  lui $1,0x00001001     128  	la	$t2,const	# coloca em $t2 o endereço da constante
0x004001bc  0x342a0024  ori $10,$1,0x00000024      
0x004001c0  0x00000000  nop                   129  	nop
0x004001c4  0x00000000  nop                   130  	nop
0x004001c8  0x00000000  nop                   131  	nop
0x004001cc  0x8d4a0000  lw $10,0x00000000($10)132  	lw	$t2,0($t2)	# coloca em $t2 a constante
0x004001d0  0x19200013  blez $9,0x00000013    133  loop:	blez	$t1,end_add	# se/quando tamanho é/torna-se 0, fim do processamento
0x004001d4  0x00000000  nop                   134  	nop
0x004001d8  0x00000000  nop                   135  	nop
0x004001dc  0x00000000  nop                   136  	nop
0x004001e0  0x00000000  nop                   137  	nop
0x004001e4  0x8d0b0000  lw $11,0x00000000($8) 138  	lw	$t3,0($t0)	# coloca em $t3 o próximo elemento do vetor
0x004001e8  0x00000000  nop                   139  	nop
0x004001ec  0x00000000  nop                   140  	nop
0x004001f0  0x00000000  nop                   141  	nop
0x004001f4  0x016a5821  addu $11,$11,$10      142  	addu	$t3,$t3,$t2	# soma constante
0x004001f8  0x00000000  nop                   143  	nop
0x004001fc  0x00000000  nop                   144  	nop
0x00400200  0x00000000  nop                   145  	nop
0x00400204  0xad0b0000  sw $11,0x00000000($8) 146  	sw	$t3,0($t0)	# atualiza no vetor o valor do elemento
0x00400208  0x25080004  addiu $8,$8,0x00000004147  	addiu	$t0,$t0,4	# atualiza ponteiro do vetor. Lembrar, 1 palavra=4 posições de memória
0x0040020c  0x2529ffff  addiu $9,$9,0xffffffff148  	addiu	$t1,$t1,-1	# decrementa contador de tamanho do vetor
0x00400210  0x08100074  j 0x004001d0          149  	j	loop		# continua execução
0x00400214  0x00000000  nop                   150  	nop
0x00400218  0x00000000  nop                   151  	nop
0x0040021c  0x00000000  nop                   152  	nop
0x00400220  0x3c011001  lui $1,0x00001001     156  end_add:li	$sp,0x10010800	# Para poder simular o hardware, inicializa-se o $sp c/valor adequado
0x00400224  0x343d0800  ori $29,$1,0x00000800      
0x00400228  0x00000000  nop                   157  	nop
0x0040022c  0x00000000  nop                   158  	nop
0x00400230  0x00000000  nop                   159  	nop
0x00400234  0x27bdfffc  addiu $29,$29,0xffffff160  	addiu	$sp,$sp,-4	# assume-se $sp inicializado, aloca espaço na pilha
0x00400238  0x00000000  nop                   162  	nop
0x0040023c  0x00000000  nop                   163  	nop
0x00400240  0x00000000  nop                   164  	nop
0x00400244  0xafbf0000  sw $31,0x00000000($29)165  	sw	$ra,0($sp)	# salva endereço de retorno de quem chamou (trap handler)
0x00400248  0x0c10009f  jal 0x0040027c        166  	jal	sum_tst		# salta para subrotina sum_tst
0x0040024c  0x00000000  nop                   167  	nop
0x00400250  0x00000000  nop                   168  	nop
0x00400254  0x00000000  nop                   169  	nop
0x00400258  0x8fbf0000  lw $31,0x00000000($29)170  	lw	$ra,0($sp)	# ao retornar, recupera endereço de retorno da pilha
0x0040025c  0x27bd0004  addiu $29,$29,0x000000171  	addiu	$sp,$sp,4	# atualiza apontador de pilha
0x00400260  0x00000000  nop                   172  	nop
0x00400264  0x00000000  nop                   173  	nop
0x00400268  0x00000000  nop                   174  	nop
0x0040026c  0x03e00008  jr $31                175  end:	jr	$ra		# FIM DO PROGRAMA AQUI. volta para o "sistema operacional" 
0x00400270  0x00000000  nop                   176  	nop
0x00400274  0x00000000  nop                   177  	nop
0x00400278  0x00000000  nop                   178  	nop
0x0040027c  0x3c011001  lui $1,0x00001001     180  sum_tst:la	$t0,var_a	# pega endereço da primeira variável (pseudo-instrução)
0x00400280  0x34280028  ori $8,$1,0x00000028       
0x00400284  0x00000000  nop                   181  	nop
0x00400288  0x00000000  nop                   182  	nop
0x0040028c  0x00000000  nop                   183  	nop
0x00400290  0x8d080000  lw $8,0x00000000($8)  184  	lw	$t0,0($t0)	# toma o valor de var_a e coloca em $t0
0x00400294  0x3c011001  lui $1,0x00001001     185  	la	$t1,var_b	# pega endereço da segunda variável (pseudo-instrução)
0x00400298  0x3429002c  ori $9,$1,0x0000002c       
0x0040029c  0x00000000  nop                   186  	nop
0x004002a0  0x00000000  nop                   187  	nop
0x004002a4  0x00000000  nop                   188  	nop
0x004002a8  0x8d290000  lw $9,0x00000000($9)  189  	lw	$t1,0($t1)	# toma o valor de var_b e coloca em $t1
0x004002ac  0x00000000  nop                   190  	nop
0x004002b0  0x00000000  nop                   191  	nop
0x004002b4  0x00000000  nop                   192  	nop
0x004002b8  0x01285021  addu $10,$9,$8        193  	addu	$t2,$t1,$t0	# soma var_a com var_b e coloca resultado em $t2
0x004002bc  0x27bdfff8  addiu $29,$29,0xffffff194  	addiu	$sp,$sp,-8	# aloca espaço na pilha
0x004002c0  0x00000000  nop                   195  	nop
0x004002c4  0x00000000  nop                   196  	nop
0x004002c8  0x00000000  nop                   197  	nop
0x004002cc  0xafaa0000  sw $10,0x00000000($29)198  	sw	$t2,0($sp)	# no topo da pilha coloca o resultado da soma
0x004002d0  0xafbf0004  sw $31,0x00000004($29)199  	sw	$ra,4($sp)	# abaixo do topo coloca o endereço de retorno
0x004002d4  0x3c010040  lui $1,0x00000040     200  	la	$t3,ver_ev	# pega endereço da subrotina ver_ev (pseudo-instrução)
0x004002d8  0x342b031c  ori $11,$1,0x0000031c      
0x004002dc  0x00000000  nop                   201  	nop
0x004002e0  0x00000000  nop                   202  	nop
0x004002e4  0x00000000  nop                   203  	nop
0x004002e8  0x0160f809  jalr $31,$11          204  	jalr	$ra,$t3		# chama subrotina que verifica se resultado da soma é par
0x004002ec  0x00000000  nop                   205  	nop
0x004002f0  0x00000000  nop                   206  	nop
0x004002f4  0x00000000  nop                   207  	nop
0x004002f8  0x8fbf0004  lw $31,0x00000004($29)208  	lw	$ra,4($sp)	# ao retornar, recupera endereço de retorno da pilha
0x004002fc  0x27bd0008  addiu $29,$29,0x000000209  	addiu	$sp,$sp,8	# atualiza apontador de pilha
0x00400300  0x00000000  nop                   210  	nop
0x00400304  0x00000000  nop                   211  	nop
0x00400308  0x00000000  nop                   212  	nop
0x0040030c  0x03e00008  jr $31                213  	jr	$ra		# Rotina acaba AQUI. Retorna para quem chamou
0x00400310  0x00000000  nop                   214  	nop
0x00400314  0x00000000  nop                   215  	nop
0x00400318  0x00000000  nop                   216  	nop
0x0040031c  0x8fab0000  lw $11,0x00000000($29)218  ver_ev:	lw	$t3,0($sp)	# tira dados to topo da pilha (parâmetro)
0x00400320  0x00000000  nop                   219  	nop
0x00400324  0x00000000  nop                   220  	nop
0x00400328  0x00000000  nop                   221  	nop
0x0040032c  0x316b0001  andi $11,$11,0x0000000222  	andi	$t3,$t3,1	# $t3 <= 1 se parâmetro é ímpar, 0 caso contrário
0x00400330  0x03e00008  jr $31                223  	jr	$ra		# e retorna
0x00400334  0x00000000  nop                   224  	nop
0x00400338  0x00000000  nop                   225  	nop
0x0040033c  0x00000000  nop                   226  	nop
